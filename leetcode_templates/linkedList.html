<!DOCTYPE html>
<html>
<head>
    <title>Linked List</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
    <header>
        <li><a href="../index.html">記事一覧</a></li>
        <li><a href="../leetcode_templates.html">templates</a></li>
    </header>
    <main>
        <h1>Linked List</h1>
        <pre><code class = "language-java">
            // before: 1-2-3-4-5-6-7
            void traverse(ListNode head) {
                if (head == null) return;
                ListNode slow = head, fast = head, dummy = new ListNode(0, head);
                // puts slow in the middle
                while (fast != null && fast.next != null) {
                    slow = slow.next;
                    fast = fast.next.next;
                }
                //        d h     s     f
                // after: 0-1-2-3-4-5-6-7
            }
        </code></pre>      

        <p>This code snippet defines a function traverse that accepts a singly linked list as its input. The purpose of the function seems to be to move a pointer (referred to as slow) to the middle node of the input list.</p>
        <p>Here's how it works:</p>

        <ol>
            <li>head is checked to see if it is null. If it is, the function returns as there is no list to traverse.</li>
            <li>Two pointers slow and fast are created at the head of the list. These are used to traverse the list at different speeds; slow will move one node at a time, while fast will move two nodes at a time. This is sometimes referred to as the "hare and tortoise" method.</li>
            <li>A third pointer, dummy, is also created and points to the head of the list. This dummy node is often used as a pre-head node. Here, however, its purpose is not very clear, as it's not used in the rest of the code.</li>
            <li>The while loop continues until fast either reaches the end of the list or the node before the end (this latter case is to prevent a null exception error when trying to access fast.next.next if the list has an even number of nodes). Within the loop, slow advances by one node and fast advances by two nodes.</li>
            <li>When the loop ends, slow is in the middle of the list. This is because fast was moving twice as fast as slow - so when fast has traversed the entire list, slow has only traversed half.</li>
        </ol>

        <p>Let's talk about time and space complexity:</p>
        <p>Time complexity: The time complexity is O(n), where n is the number of nodes in the list. This is because each node is visited at most twice (once by the slow pointer, once by the fast pointer).</p>
        <p>Space complexity: The space complexity is O(1), as no additional space is used that scales with the size of the input. The three pointers slow, fast, and dummy are the only extra space used, and this does not change with the size of the list.</p>

    </main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js"></script>
</body>
</html>
